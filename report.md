# Анализ C++ кода - анализ покрытия.
## Ведение.
**Покрытие кода** — мера, используемая при тестировании программного обеспечения. Она представляет собой показатель того, какая часть исходного кода охвачена тестами, используя различные критерии, исходя из которых высчитывается процент охвата [1]. Карл Вигерс сообщает, что тестирование, выполняемое без измерения покрытия кода тестами, обычно охватывает только 50–60% кода (Wiegers, 2002). Монитор покрытия — это инструмент, который следит за тем, какой код тестировался, а какой нет. Если вы выполнили полный набор тестов, а монитор покрытия сообщает, что какой-то код все еще не протестирован, значит, нужны дополнительные тесты (не всегда – далее будет понятно почему) [2]. 
## Оценка покрытия кода.
Для определения степени покрытия кода тестами может быть использовано множество критериев, но все они различаются в зависимости от подхода к тестированию: 
* A.	Оценивание, отталкивающееся от потока исходного кода (control flow code coverage). Идея в том, чтобы проследить поток выполнения тестовых примеров в коде.
  + Покрытие инструкций (statement coverage): это количество инструкций исходного кода, которое было выполнено хотя бы один раз в процессе выполнения тестов. Это самый простой тип покрытия.
  + Покрытие ветвлений (branch coverage): была ли каждая ветка (DD-путь) выполнена?
  + Покрытие функций (function coverage): количество вызванных функций функций на тестовых данных.
  + Покрытие решений (decision coverage): совокупность покрытия функций и ветвлений программы. Этот критерий требует, чтобы каждая точка входа/выхода программы была посещена хотя бы раз и каждое решение в программе принималось по всем возможным результатам по крайней мере один раз.
  + Condition – decision coverage (C - DC): критерий, расширяющий покрытие ветвлений, гарантирует проверку всех возможных комбинаций условий, влияющих на ветвления (а не только true и false глобального условия).
  + MC/DC (Modified condition/decision coverage) покрытие (MC/DC coverage): Этот критерий охватывает только комбинации атомарных условий, в которых значение атомарного условия может независимо влиять на общее решение. Другими словами, результат общего решения изменяется в результате изменения каждого отдельного условия.
    ![all text](https://github.com/rofeleo/misis2023f-22-02-anashkin-i-a/blob/main/docs/pic2.png)
  + Покрытие циклов (loop coverage): Покрытие циклов помогает тщательно протестировать циклы и показывает, повторялся ли каждый цикл более одного раза. Выполнение тела цикла хотя бы один раз может быть покрыто покрытием ветви, но для того, чтобы убедиться, что цикл был выполнен более одного раза, требуется покрытие цикла.
* **B. Оценивание, отталкивающееся от входных данных (data-flow code coverage).** Идея в том, чтобы исследовать способы, которыми значения связаны с переменными, и того, как эти переменные с данными значения могут повлиять на выполнение программы. Каждое появление переменной рассматривается как определение (def) или как использование (use).
  +	Def-use pair coverage: критерии охвата пары def-use проверяют, было ли использование переменной должным образом протестировано в отношении различных возможных точек ее определения.

Показатель покрытия инструкций, несмотря на популярность, плохо пригоден для нахождения ошибок (поскольку выполнение строки не обязательно выявляет ошибку в этой строке). Максимизация нескольких критериев, отталкивающихся от потоков исходного кода, лучше, чем оптимизация одного сильного (MC/DC или branch coverage), однако критерий Def-use pair coverage позволяет обнаружить множество необнаруженных неисправностей (79% необнаруженных неисправностей с помощью методов контроля потока могут быть обнаружены с помощью def/use pair coverage метода), но требует значительных вычислительных ресурсов. В среднем 15% неисправностей могут быть не обнаружены ни по одному из стандартных критериев, но классификация необнаруженных ошибок показала, что они в основном связаны со спецификацией (отсутствует логика) (faults of omission). [3]. 

## Проблемы при анализе покрытия кода.
Анализ покрытия кода не может обнаружить ошибки, которые исправляются путем добавления нового кода, они иногда называются ошибками упущения (faults of omission). 
![all text](https://github.com/rofeleo/misis2023f-22-02-anashkin-i-a/blob/main/docs/pic1.png)
Допустим, что функция perform_operation() может вернуть 3 значения: FATAL_ERROR, ALL_OK, RECOVERABLE_ERROR. Тогда, если выполнить программу на тестовых данных, при которых покрытие данного условия достигает 100% (т. е. программа входит и в if и в else на разных тестовых данных), то ошибочная обработка результата RECOVERABLE_ERROR не будет обнаружена. [4]

## Советы по использованию показателя покрытия кода.
Разработка вашего первоначального набора тестов для достижения 100%-ого охвата – плохая идея. Это верный способ создать набор тестов, слабый в поиске ошибок вида faults of omission.

**Примерный сценарий использования показателя покрытия кода:**
1.	Разделить код на три категории:
    -	Высокий риск: код, неправильная работа которого способна причинить серьезные проблемы (очистка данных, неправильный ответ, который может стоить пользователю больших денег).
    -	Низкий риск: маловероятно, что в коде будут ошибки, достаточно важные, чтобы остановить или задержать работу, даже если все ошибки суммировать. Это будут ошибки в несущественных функциях, с простыми и очевидными обходными путями.
    -	Средний риск: код находится где-то посередине. Ошибки здесь не были бы критичными по отдельности, но в совокупности привело бы к сбою в программе. Есть смысл найти и исправить их как можно скорее и как можно дешевле. Но отдача здесь уменьшается - время, затраченное на более тщательное тестирование, лучше было бы потратить на другие задачи.
2.	Тщательное тестирование кода в категории высокого риска
3.	Когда тестирование кода в категории высокого риска завершено, можно проверить покрытие процент покрытия кода
    + a. Так как код в категории высокого риска тестировался тщательно, то ожидается, что его покрытие будет высоким. Но все же, если есть непокрытые части важного кода, то следует правильно их обработать:
       - I.	Подумать, какую задачу в интерфейсе выполняет это условие.
       - II.	Подумать, как можно протестировать выполнение этой задачи, не беря в расчёт задачу повышения покрытия кода. Следует думать только о том, какого рода ошибки при разработке тестов они представляют.
       - III.	Запустить новые тесты. Ожидается, что пропущенные фрагменты кода будут покрыты в будущем, даже если специально не подбирать тесты для их покрытия. Если позже этот участок кода не будет покрыт, то проблема в составлении тестов (со стороны направленности этих тестов).
    + b. Ожидается меньшее покрытие кода со средним риском. Следует просмотреть лог покрытия (монитора покрытия) и проверить есть ли в пропущенном коде что-то такое, что стоит тестировать отдельно, что может доставить неприятности клиенту. Не следует тратить больше времени на обработку результатов покрытия, чем на более тщательное тестирование.
    + c.	Покрытие кода с низким риском довольно неинтересный для нас показатель. Может быть использован для поиска кода, который никогда не вызывается [4].

## Вывод.
Показатель покрытия кода – важный показатель, на который следует обращать внимание при тестировании ПО, но не следует вслепую максимизировать его, стараясь достичь максимума.

## Примеры программ для тестирования c++ кода на покрытие (мониторы покрытия).
1.	CppUnit: Это популярная библиотека для тестирования и анализа покрытия кода на C++. Она предоставляет набор инструментов для написания модульных тестов, а также для измерения и отображения покрытия кода.
2.	GCC’s gcov: Это инструмент, который работает в связке с компилятором GCC и анализирует покрытие кода. Он собирает информацию о том, какие строки кода были выполнены во время исполнения программы, и создает отчеты о покрытии кода.
3.	LLVM’s coverage-instrumentation pass: Этот инструмент работает с компилятором LLVM и предоставляет возможность измерения покрытия кода во время сборки. Он может быть использован для создания отчетов о покрытии как для исходного кода, так и для машинного кода.
4.	Coverity: Это коммерческая программа для анализа покрытия кода, которая работает с различными языками программирования, включая C++. Она использует статический анализ исходного кода для определения покрытия и предоставляет подробные отчеты о покрытии.
5.	SonarQube: Это платформа для непрерывной интеграции и контроля качества кода, которая поддерживает анализ покрытия кода C++. Она позволяет измерять покрытие кода и предоставляет отчеты о качестве кода.
## Ссылки
1.	Ibrahim A. A. Bridging the Gap: Developing a Standardized Framework for any C++ Code Coverage Tool // 2023. - С. 4.
2.	Макконнелл С. Совершенный код. - 2-е изд. - Русская редакция, 2010. - 900 с.
3.	Hemmati H. How Effective Are Code Coverage Criteria? // 2015 IEEE International Conference on Software Quality, 2015. - С. 155.
4.	Marick B. How to Misuse Code Coverage // С. 5-6.

